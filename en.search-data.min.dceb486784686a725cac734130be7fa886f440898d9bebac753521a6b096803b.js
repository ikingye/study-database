'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/study-database/docs/postgresql/basic/quick-start/','title':"快速上手",'content':"快速上手 安装 MacOS  安装：brew install postgresql 启动：brew services start postgresql 创建用户名数据库：createdb  基础命令 登录 PostgreSQL 控制台：psql psql -U [user] -d [database] -h [host] -p [port]\n默认 psql\nuser：当前mac用户 database：用户同名数据库 主机：localhost 端口号：5432，postgresql的默认端口是5432 \\l 使用 \\l 命令列出所有的数据库，看到已存在用户同名数据库、postgres 数据库。 但是 postgres 数据库的所有者是当前用户，没有 postgres 用户。\n 创建 postgres 用户：CREATE USER postgres WITH PASSWORD 'password'; 删除默认生成的 postgres 数据库：DROP DATABASE postgres; 创建属于 postgres 用户的 postgres 数据库：CREATE DATABASE postgres OWNER postgres; 将数据库所有权限赋予 postgres 用户：GRANT ALL PRIVILEGES ON DATABASE postgres to postgres; 给 postgres 用户添加创建数据库的属性：ALTER ROLE postgres CREATEDB;  常用控制台命令 \\password：设置当前登录用户的密码 \\h：查看SQL命令的解释，比如\\h select。 \\?：查看psql命令列表。 \\l：列出所有数据库。 \\c [database_name]：连接其他数据库。 \\d：列出当前数据库的所有表格。 \\d [table_name]：列出某一张表格的结构。 \\du：列出所有用户。 \\e：打开文本编辑器。 \\conninfo：列出当前数据库和连接的信息。 \\password [user]: 修改用户密码 \\q：退出 "});index.add({'id':1,'href':'/study-database/docs/mysql/basic/practice/optimize/','title':"性能优化",'content':"Mysql 性能优化 存储引擎 使用 Innodb 存储引擎 没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。\nInnodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n 编码 统一使用 UTF8 库和表的字符集统一使用 UTF8\n 表 控制单表数据量的大小 建议在 500 万以内。500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n谨慎使用 MySQL 分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n谨慎选择分区键，跨分区查询效率可能更低；\n建议采用物理分表的方式管理大数据。\n冷热数据分离，减小表的宽度  MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。\n 减少磁盘 IO, 保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大，也会消耗更多的 IO）；\n更有效的利用缓存，避免读入无用的冷数据；\n经常一起使用的列放到一个表中（避免更多的关联操作）。\n优先选择小的数据类型 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少也越少，在遍历时所需要的 IO 次数也就越多，索引的性能也就越差。\n如：\n 将 IP 地址转换成整形数据 对于非负型的数据 (如自增 ID, 整型 IP) 来说，要优先使用无符号整型来存储  列定义为 NOT NULL 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。\n进行比较和计算时要对 NULL 值做特别的处理。\n 索引 限制每张表上的索引数量 建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样可以降低效率。\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n必须有个主键 Innodb 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\nInnodb 是按照主键索引的顺序来组织表的\n 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID,MD5,HASH, 字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增 ID 值   开发 避免数据类型的隐式转换 避免使用双 % 号的查询条件 联合索引 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧。\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n使用 left join 替代 not in 操作 使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n 参考  MySQL 高性能优化规范建议  "});index.add({'id':2,'href':'/study-database/docs/mysql/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':3,'href':'/study-database/docs/postgresql/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':4,'href':'/study-database/docs/redis/appendix/tutorial/','title':"教程",'content':"教程 基础 进阶 高阶 "});index.add({'id':5,'href':'/study-database/docs/mysql/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':6,'href':'/study-database/docs/postgresql/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':7,'href':'/study-database/docs/mysql/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':8,'href':'/study-database/docs/postgresql/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':9,'href':'/study-database/docs/redis/basic/','title':"第一部分 基础入门",'content':""});index.add({'id':10,'href':'/study-database/docs/mysql/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':11,'href':'/study-database/docs/postgresql/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':12,'href':'/study-database/docs/redis/basic/practice/spec/','title':"编程规范",'content':"编程规范 "});index.add({'id':13,'href':'/study-database/docs/mysql/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':14,'href':'/study-database/docs/postgresql/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':15,'href':'/study-database/docs/redis/appendix/interview/basic/','title':"基础",'content':"基础面试题 "});index.add({'id':16,'href':'/study-database/docs/mysql/design/','title':"第二部分 设计",'content':""});index.add({'id':17,'href':'/study-database/docs/postgresql/design/','title':"第二部分 设计",'content':""});index.add({'id':18,'href':'/study-database/docs/redis/design/','title':"第二部分 设计",'content':""});index.add({'id':19,'href':'/study-database/docs/mysql/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':20,'href':'/study-database/docs/postgresql/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':21,'href':'/study-database/docs/redis/appendix/interview/advanced/','title':"进阶",'content':"进阶面试题 "});index.add({'id':22,'href':'/study-database/docs/mysql/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':23,'href':'/study-database/docs/postgresql/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':24,'href':'/study-database/docs/redis/appendix/interview/','title':"面试题",'content':"面试题 基础题 进阶题 高阶题 "});index.add({'id':25,'href':'/study-database/docs/mysql/source/','title':"第三部分 源码实现",'content':""});index.add({'id':26,'href':'/study-database/docs/postgresql/source/','title':"第三部分 源码实现",'content':""});index.add({'id':27,'href':'/study-database/docs/redis/source/','title':"第三部分 源码实现",'content':""});index.add({'id':28,'href':'/study-database/docs/mysql/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':29,'href':'/study-database/docs/postgresql/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':30,'href':'/study-database/docs/redis/appendix/interview/expert/','title':"高阶",'content':"高阶面试题 "});index.add({'id':31,'href':'/study-database/docs/mysql/appendix/','title':"第四部分 附录",'content':""});index.add({'id':32,'href':'/study-database/docs/postgresql/appendix/','title':"第四部分 附录",'content':""});index.add({'id':33,'href':'/study-database/docs/redis/appendix/','title':"第四部分 附录",'content':""});index.add({'id':34,'href':'/study-database/docs/mysql/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':35,'href':'/study-database/docs/postgresql/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':36,'href':'/study-database/docs/redis/basic/practice/snippet/','title':"代码片段",'content':"代码片段 "});index.add({'id':37,'href':'/study-database/docs/redis/basic/type/','title':"数据类型",'content':"数据类型 string Redis 规定了字符串的长度不得超过 512 MB。\nlist hash set zset "});index.add({'id':38,'href':'/study-database/docs/redis/basic/cmd/','title':"命令",'content':"Redis 命令 key  DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   string  APPEND DECR DECRBY DEL EXISTS GET GETRANGE GETSET INCR INCRBY INCRBYFLOAT MGET MSET MSETNX PSETEX SET SETBIT SETEX SETNX STRLEN   list  DEL DUMP EXISTS EXPIRE EXPIREAT KEYS MOVE PERSIST PEXPIREAT PEXPIREAT PTTL RANDOMKEY RENAME RENAMENX TTL TYPE   hash  HDEL HEXISTS HGET HGETALL HINCRBY HINCRBYFLOAT HKEYS HLEN HMGET HMSET HSET HSETNX HVALS   set  SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SSCAN SUNION SUNIONSTORE   zset  ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZLEXCOUNT ZRANGE ZRANGEBYLEX ZRANGEBYSCORE ZRANK ZREM ZREMRANGEBYLEX ZREMRANGEBYRANK ZREMRANGEBYSCORE ZREVRANGE ZREVRANGEBYSCORE ZREVRANK ZSCAN ZSCORE ZUNIONSTORE   连接  AUTH ECHO PING QUIT SELECT   服务器  BGREWRITEAOF BGSAVE CLIENT GETNAME CLIENT KILL CLIENT LIST CLIENT PAUSE CLIENT SETNAME CLUSTER SLOTS COMMAND COMMAND COUNT COMMAND GETKEYS COMMAND INFO CONFIG GET CONFIG RESETSTAT CONFIG REWRITE CONFIG SET DBSIZE DEBUG OBJECT DEBUG SEGFAULT FLUSHALL FLUSHDB INFO LASTSAVE MONITOR ROLE SAVE SHOWLOG SHUTDOWN SLAVEOF SYNC TIME   脚本  EVAL EVALSHA SCRIPT EXISTS SCRIPT FLUSH SCRIPT KILL SCRIPT LOAD   事务  DISCARD EXEC MULTI UNWATCH WATCH   HyperLogLog  PFADD PFCOUNT PGMERGE   发布订阅  PSUBSCRIBE PUBLISH PUBSUB PUNSUBSCRIBE SUBSCRIBE UNSUBSCRIBE   地理位置 (geo)  GEOADD GEODIST GEOHASH GEOPOS GEORADIUS GEORADIUSBYMEMBER   参考  www.redis.net.cn/order 神奇的 HyperLogLog 算法  "});index.add({'id':39,'href':'/study-database/docs/redis/source/type/','title':"类型实现",'content':"Redis 类型实现 参考  5 种基本数据结构  "});index.add({'id':40,'href':'/study-database/docs/mysql/','title':"Mysql",'content':"Mysql "});index.add({'id':41,'href':'/study-database/docs/redis/source/type/string/','title':"String 实现",'content':"Redis String 类型实现 Redis 中的字符串是一种 动态字符串，这意味着使用者可以修改，它的底层实现有点类似于 Java 中的 ArrayList，有一个字符数组，从源码的 sds.h/sdshdr 文件 中可以看到 Redis 底层对于字符串的定义 SDS，即 Simple Dynamic String 结构：\n/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 你会发现同样一组结构 Redis 使用泛型定义了好多次，为什么不直接使用 int 类型呢？\n因为当字符串比较短的时候，len 和 alloc 可以使用 byte 和 short 来表示，Redis 为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。\nSDS 与 C 字符串的区别 为什么不考虑直接使用 C 语言的字符串呢？\nC 字符串太简单 因为 C 语言这种简单的字符串表示方式 不符合 Redis 对字符串在安全性、效率以及功能方面的要求。\nC 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 \u0026lsquo;\\0\u0026rsquo;。\n这样简单的数据结构可能会造成以下一些问题：\n 获取字符串长度为 O (N) 级别的操作 → 因为 C 不保存数组的长度，每次都需要遍历一遍整个数组； 不能很好的杜绝 缓冲区溢出 / 内存泄漏 的问题 → 跟上述问题原因一样，如果执行拼接 or 缩短字符串的操作，如果操作不当就很容易造成上述问题； C 字符串 只能保存文本数据 → 因为 C 语言中的字符串必须符合某种编码（比如 ASCII），例如中间出现的 \u0026lsquo;\\0\u0026rsquo; 可能会被判定为提前结束的字符串而识别不了；  以追加字符串的操作举例，Redis 源码如下：\n/* Append the specified binary-safe string pointed by \u0026#39;t\u0026#39; of \u0026#39;len\u0026#39; bytes to the * end of the specified sds string \u0026#39;s\u0026#39;. * * After the call, the passed sds string is no longer valid and all the * references must be substituted with the new pointer returned by the call. */ sds sdscatlen(sds s, const void *t, size_t len) { // 获取原字符串的长度  size_t curlen = sdslen(s); // 按需调整空间，如果容量不够容纳追加的内容，就会重新分配字节数组并复制原字符串的内容到新数组中  s = sdsMakeRoomFor(s,len); if (s == NULL) return NULL; // 内存不足  memcpy(s+curlen, t, len); // 追加目标字符串到字节数组中  sdssetlen(s, curlen+len); // 设置追加后的长度  s[curlen+len] = \u0026#39;\\0\u0026#39;; // 让字符串以 \\0 结尾，便于调试打印  return s; }  参考  5 种基本数据结构  "});index.add({'id':42,'href':'/study-database/docs/redis/basic/practice/','title':"最佳实践",'content':"最佳实践 "});index.add({'id':43,'href':'/study-database/docs/redis/source/type/list/','title':"List 实现",'content':"Redis List 类型实现  参考  5 种基本数据结构  "});index.add({'id':44,'href':'/study-database/docs/postgresql/','title':"PostgreSQL",'content':"PostgreSQL "});index.add({'id':45,'href':'/study-database/docs/redis/','title':"Redis",'content':"Redis "});index.add({'id':46,'href':'/study-database/categories/','title':"Categories",'content':""});index.add({'id':47,'href':'/study-database/docs/','title':"Docs",'content':""});index.add({'id':48,'href':'/study-database/tags/','title':"Tags",'content':""});index.add({'id':49,'href':'/study-database/','title':"首页",'content':""});})();